# riscv-sleuth
## Overview
I have been working on a project over the past few weeks to implement a disassembler for RISC-V binaries. This project uses Capstone for disassembly and Streamlit for the user interface, allowing you to upload a binary file, decode it, and visualize the opcode frequency.

The tool extracts code sections from ELF files, disassembles the instructions, counts the frequency of opcodes, and presents the results in a user-friendly format.

Inspired by the paper "Trustworthy Verification of RISC-V Binaries Using Symbolic Execution" by Palmskog et al. (2025)which discusses the verification of RISC-V binaries through symbolic execution (and the picoCTF Cybersecurity Compeition), this tool provides a basic but somewhat effective approach to disassembling RISC-V binaries and analyzing their true structure.

![image](https://github.com/user-attachments/assets/bdcc02ac-e4cc-4964-b29f-670fb2c80baa)


## Requirements
```bash
streamlit==1.12.0
capstone==4.0.1
matplotlib==3.5.1
```

## Example Usage
### Running the Application
To run the disassembler and visualize opcode frequencies, follow these steps:

Install the required dependencies:

```bash
pip install streamlit capstone matplotlib
```

Save the code to a file, e.g., riscv_disassembler.py.

Run the Streamlit app:

```bash
streamlit run riscv_disassembler.py
```

Upload your RISC-V binary file through the Streamlit UI, or use the provided ELF file (still in the works).

### Functionality
1. ELF File Extraction: Extracts the .text section from RISC-V ELF binaries.
2. Disassembly: Uses Capstone to decode the binary data into human-readable instructions.
3. Opcode Frequency Analysis: Counts the frequency of each opcode and visualizes it using a bar chart.
4. Disassembled Instructions Display: Shows the address, bytes, mnemonic, and operands of each instruction in a table.

## Example Screenshots
### Visualization of Instruction Frequency
Here’s an example of the opcode frequency chart generated by the tool, showing the most common opcodes in a RISC-V binary.

<img width="293" alt="image" src="https://github.com/user-attachments/assets/f3a72463-1606-4448-906e-3fc13c37c547" />



### Disassembled Instructions
This screenshot shows a table of disassembled instructions, including the address, bytes, mnemonic, and operands.

<img width="315" alt="image" src="https://github.com/user-attachments/assets/161f96f3-3ee9-4dc5-8a7d-de6ae5d7a194" />


## Insights from Research Paper
This tool is inspired by the research conducted by Palmskog et al. in their paper "Trustworthy Verification of RISC-V Binaries Using Symbolic Execution" (arXiv:2503.14135). The authors propose a formal workflow for RISC-V binary analysis using HOL4 and HolBA, which validates the correctness of disassembled binaries. This approach uses symbolic execution to ensure that the disassembly process accurately reflects the intended behavior of the binary.

Although the tool here focuses on static analysis with Capstone, insights from the paper have influenced its design, especially the integration of disassembly and opcode frequency analysis in a verification context.

You can access the full research paper here: [Trustworthy Verification of RISC-V Binaries Using Symbolic Execution](https://arxiv.org/abs/2503.14135)

## Random Footnotes
The code uses Capstone for disassembly, which makes it easier to parse and decode RISC-V binaries. I initially experimented with other disassemblers but found Capstone’s interface to be the most user-friendly for RISC-V.

The ELF file parsing section is based on a basic approach but could be improved for more complex binaries or edge cases.

This tool is still a work in progress, and there are a lot of optimizations that could be done, such as refining the user interface or adding support for more advanced features like symbolic execution (as seen in the Palmskog et al. paper).
